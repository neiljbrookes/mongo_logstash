input {
	stdin {
	
	}
}

filter {

	# Initial grok to remove the syslog timestamp

	grok {
		match => [ "message" , "%{SYSLOGBASE} %{GREEDYDATA:message}" ]
		overwrite => [ "message" ]
	}

	# If the log comes from mongo, then fall into this conditional
	if [program] =~ "mongos" {
		# Mutate the timestamp field into syslog_timestamp.
		# We will populate 'timestamp' with the value from the mongo process
		mutate {
			rename => [ "timestamp" , "syslog_timestamp" ]
			add_tag => "mongos"
		}
		# Use the %MONGO_LOG pattern to pull out the timestamp. 
		# Overwrite the message abd timestamp fields
		# Add a new field
		grok {
			break_on_match => false
			match => [ "message" , "%{MONGO_LOG}" ]
			overwrite => [ "message" , "timestamp" ]
			add_field => { "mongo_timestamp" => "%{timestamp}" }
			add_tag => [ "%{component}" ]
		}
		# Capture the following lines
		#
		# Jan 14 12:50:55 lonapp0-2vz74 mongos.23074[2420]: Wed Jan 14 12:50:55.254 [mongosMain] connection accepted from 10.183.224.66:53539 #4364679 (12 connections now open)
		#
		#
		if [component] == "mongosMain" {
			grok {
				break_on_match => false
				match => ["message" , "connection accepted from %{IP:connect_from}:%{POSINT:connect_from_port} %{DATA} \(%{POSINT:open_conns} connections now open\)"]
			}
		}
		# Capture the following lines
		#
		# Jan 14 03:04:38 lonapp0-1vz74 mongos.23074[30689]: Wed Jan 14 03:04:38.379 [conn150814]  authenticate db: stats_1412015 { authenticate: 1, user: "pl_user", nonce: "527659fde28e6a17", key: "e5a7a2470e2ac7d4429fb735ba197138" }
		#
		#
		if [component] =~ "conn" {
			if [message] =~ "authenticate db" {
				grok {
					break_on_match => false
					match => [ "message", " authenticate db: %{WORD:auth_db} { %{GREEDYDATA:message} }" ]
					overwrite => [ "message" ]
				}
				kv {
					value_split => ": "
					field_split => ","
					trim => " \\\""
				}
			}#IF
			else {
				grok {
					break_on_match => false
					match => ["message" , "end connection %{IP:connect_from}:%{POSINT:connect_from_port} \(%{POSINT:open_conns} connections now open\)"]
				}
			}
		}#IF
		if [component] == "Balancer" {

		}
		
	}#if

	if [program] =~ "mongod" {
                # Mutate the timestamp field into syslog_timestamp.
                # We will populate 'timestamp' with the value from the mongo process
                mutate {
                        rename => [ "timestamp" , "syslog_timestamp" ]
                        add_tag => "mongod"
                }
		grok {
                        match => [ "message" , "%{MONGO_LOG}" ]
                        overwrite => [ "message" , "timestamp" ]
                        add_field => { "mongo_timestamp" => "%{timestamp}" }
			add_tag => [ "%{component}" ]
                }
		if [component] == "initandlisten" {
			grok {
                                break_on_match => false
                                match => ["message" , "connection accepted from %{IP:connect_from}:%{POSINT:connect_from_port} %{DATA} \(%{POSINT:open_conns:int} connections now open\)"]
                        }
		}
		if [component] =~ "conn" {
			if [message] =~ "end connection" {
				mutate {
					add_tag => [ "end_connection" ]
				}
			}
		}
	}

	date {
		match => [ "timestamp","MMM DD HH:mm:ss.SSS", "MMM DD HH:mm:ss" ]
	}
}

output {

	stdout { 
		codec => rubydebug 
	}
	elasticsearch {
		host => "134.213.133.52"
	}
}
